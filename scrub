#!/usr/bin/env ruby

require 'json'
require 'optparse'
require 'ostruct'

class Scrubber

  attr_reader :failures
  attr_reader :options
  attr_reader :root_dir
  attr_reader :status

  def self.scrub(root_dir, options = {})
    new(root_dir, options).scrub
  end

  def initialize(root_dir, options = {})
    @failures = []
    @options = options
    @root_dir = File.realpath(root_dir)
    @status = :ok
  end

  def scrub(dir = @root_dir)
    hash_file = hashes_filename(dir)
    if File.exist?(File.join(dir, 'noscrub'))
      if File.exists?(hash_file)
        File.unlink(hash_file)
      end
      return self
    end

    # restore hashes if already scrubbed
    expected_hashes = hashes(dir)
    new_hashes = {}

    # walk the directory
    Dir[File.join(dir, '*')].each do |file|

      # skip broken symlinks
      next if File.symlink?(file) && !File.exist?(file)

      # descend into subdirectories
      if File.directory?(file)
        scrub(file)

      # scrub this file
      else
        basename = File.basename(file)
        expected_hash = expected_hashes[basename]
        next if basename == 'scrub.json'
        if options.skip_existing && expected_hash
          new_hashes[basename] = expected_hash
          next
        end
        relative_filename = file.sub(@root_dir + '/', '')
        result, hash = scrub_file(file, expected_hash)
        case result
        when :ok
          new_hashes[basename] = hash
          puts "[ok]   #{hash} - #{relative_filename}" if options.verbose
        when :new
          new_hashes[basename] = hash
          puts "[new]  #{hash} - #{relative_filename}" if options.verbose
        when :fail
          @failures << {
            :filename => relative_filename,
            :hash => hash,
            :expected_hash => expected_hash
          }
          @status = :fail
          puts "[FAIL] #{hash} - #{relative_filename} (previously had sha #{expected_hash})"
        end
      end
    end

    write_hashes(dir, new_hashes)
    self
  end

  # Returns 
  def scrub_file(file, expected_hash)
    basename = File.basename(file)
    hash = sha1(file)
    result =
      if hash == expected_hash
        result = :ok
      elsif expected_hash
        result = :fail
      else
        result = :new
      end
    [result, hash]
  end

  def ok?
    @status == :ok
  end

  def fail?
    @status == :fail
  end

  def sha1(filename)
    # holy quoting batman!
    `shasum "#{filename.gsub(/(\$)/, '\\\\\\1')}"`.split.first
  end

  def hashes_filename(dir)
    File.join(dir, 'scrub.json')
  end

  def hashes(dir)
    f = hashes_filename(dir)
    if File.exist?(f)
      JSON.parse(File.read(f))
    else
      {}
    end
  end

  def write_hashes(dir, hashes)
    return if options.phantom
    f = hashes_filename(dir)
    if hashes.size > 0
      File.open(f, 'w') { |f| f.puts(JSON.fast_generate(hashes)) }
    elsif File.exists?(f)
      File.unlink(f)
    end
  end

end

def main
  options = OpenStruct.new
  options.phantom = false
  options.skip_existing = false
  options.verbose = false

  OptionParser.new do |opts|
    opts.banner = 'Usage: scrub [options] <root-directory>'
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit
    end
    opts.on('-p', '--phantom', 'Do everything except write scrub.json files. Useful for testing.') do
      options.phantom = true
    end
    opts.on('-s', '--skip-existing', 'Only calculate new checksums, skipping files with existing hashes') do
      options.skip_existing = true
    end
    opts.on('-v', '--verbose', 'Log every file that is checked') do
      options.verbose = true
    end
  end.parse!

  root_dir = ARGV.shift || '.'
  unless File.directory?(root_dir)
    puts "error: #{root_dir} is not directory"
    exit 1
  end

  result = Scrubber.scrub(root_dir, options)

  # TODO print a summary

  # Failures may have been lost in the noise so report them at the
  # end as well when -v is given.
  if result.fail? && options.verbose
    puts
    puts "*** Failures:"
    # report failures
    result.failures.sort do |a,b|
      a[:filename] <=> b[:filename]
    end.each do |failure|
      puts "#{failure[:filename]}: expected #{failure[:expected_hash]}, but got #{failure[:hash]}"
    end
    exit 1
  end
end

main if $0 == __FILE__
